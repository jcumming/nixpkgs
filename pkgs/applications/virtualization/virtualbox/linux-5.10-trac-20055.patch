diff -rc VirtualBox-6.1.16.orig/src/VBox/Additions/linux/drm/vbox_drv.h VirtualBox-6.1.16.new/src/VBox/Additions/linux/drm/vbox_drv.h
*** VirtualBox-6.1.16.orig/src/VBox/Additions/linux/drm/vbox_drv.h	2020-10-16 09:30:13.000000000 -0700
--- VirtualBox-6.1.16.new/src/VBox/Additions/linux/drm/vbox_drv.h	2020-12-24 13:24:31.459148337 -0800
***************
*** 196,201 ****
--- 196,208 ----
  }
  #endif
  
+ #ifndef TTM_PL_FLAG_SYSTEM
+ #define TTM_PL_FLAG_SYSTEM      (1 << TTM_PL_SYSTEM)
+ #endif
+ #ifndef TTM_PL_FLAG_VRAM
+ #define TTM_PL_FLAG_VRAM        (1 << TTM_PL_VRAM)
+ #endif
+ 
  #define DRIVER_AUTHOR       VBOX_VENDOR
  
  #define DRIVER_NAME         "vboxvideo"
Only in VirtualBox-6.1.16.new/src/VBox/Additions/linux/drm: vbox_drv.h.orig
diff -rc VirtualBox-6.1.16.orig/src/VBox/Additions/linux/drm/vbox_ttm.c VirtualBox-6.1.16.new/src/VBox/Additions/linux/drm/vbox_ttm.c
*** VirtualBox-6.1.16.orig/src/VBox/Additions/linux/drm/vbox_ttm.c	2020-10-16 09:30:13.000000000 -0700
--- VirtualBox-6.1.16.new/src/VBox/Additions/linux/drm/vbox_ttm.c	2020-12-24 13:24:31.459148337 -0800
***************
*** 373,383 ****
--- 373,395 ----
  	bo->placement.busy_placement = bo->placements;
  
  	if (domain & TTM_PL_FLAG_VRAM)
+ #if RTLNX_VER_MIN(5,10,0)
+ 		bo->placements[c].mem_type = TTM_PL_VRAM;
+ 		PLACEMENT_FLAGS(bo->placements[c++]) =
+ 		    TTM_PL_FLAG_WC | TTM_PL_FLAG_UNCACHED;
+ #else
  		PLACEMENT_FLAGS(bo->placements[c++]) =
  		    TTM_PL_FLAG_WC | TTM_PL_FLAG_UNCACHED | TTM_PL_FLAG_VRAM;
+ #endif
  	if (domain & TTM_PL_FLAG_SYSTEM)
+ #if RTLNX_VER_MIN(5,10,0)
+ 		bo->placements[c].mem_type = TTM_PL_SYSTEM;
+ 		PLACEMENT_FLAGS(bo->placements[c++]) =
+ 		    TTM_PL_MASK_CACHING;
+ #else
  		PLACEMENT_FLAGS(bo->placements[c++]) =
  		    TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM;
+ #endif
  	if (!c)
  		PLACEMENT_FLAGS(bo->placements[c++]) =
  		    TTM_PL_MASK_CACHING | TTM_PL_FLAG_SYSTEM;
diff -rc VirtualBox-6.1.16.orig/src/VBox/Additions/linux/sharedfolders/regops.c VirtualBox-6.1.16.new/src/VBox/Additions/linux/sharedfolders/regops.c
*** VirtualBox-6.1.16.orig/src/VBox/Additions/linux/sharedfolders/regops.c	2020-10-16 09:30:14.000000000 -0700
--- VirtualBox-6.1.16.new/src/VBox/Additions/linux/sharedfolders/regops.c	2020-12-24 13:16:50.007623526 -0800
***************
*** 1401,1407 ****
      /*
       * Check that this is valid user memory that is actually in the kernel range.
       */
! #if RTLNX_VER_MIN(5,0,0) || RTLNX_RHEL_MIN(8,1)
      if (   access_ok((void *)uPtrFrom, cPages << PAGE_SHIFT)
          && uPtrFrom >= USER_DS.seg)
  #else
--- 1401,1410 ----
      /*
       * Check that this is valid user memory that is actually in the kernel range.
       */
! #if RTLNX_VER_MIN(5,10,0)
!     if (   access_ok((void *)uPtrFrom, cPages << PAGE_SHIFT)
!         && uPtrFrom >= TASK_SIZE_MAX)
! #elif RTLNX_VER_MIN(5,0,0) || RTLNX_RHEL_MIN(8,1)
      if (   access_ok((void *)uPtrFrom, cPages << PAGE_SHIFT)
          && uPtrFrom >= USER_DS.seg)
  #else
diff -rc VirtualBox-6.1.16.orig/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c VirtualBox-6.1.16.new/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c
*** VirtualBox-6.1.16.orig/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c	2020-10-16 09:38:11.000000000 -0700
--- VirtualBox-6.1.16.new/src/VBox/Runtime/r0drv/linux/memobj-r0drv-linux.c	2020-12-24 13:24:04.873269899 -0800
***************
*** 56,64 ****
   * Whether we use alloc_vm_area (3.2+) for executable memory.
   * This is a must for 5.8+, but we enable it all the way back to 3.2.x for
   * better W^R compliance (fExecutable flag). */
! #if RTLNX_VER_MIN(3,2,0) || defined(DOXYGEN_RUNNING)
  # define IPRT_USE_ALLOC_VM_AREA_FOR_EXEC
  #endif
  
  /*
   * 2.6.29+ kernels don't work with remap_pfn_range() anymore because
--- 56,67 ----
   * Whether we use alloc_vm_area (3.2+) for executable memory.
   * This is a must for 5.8+, but we enable it all the way back to 3.2.x for
   * better W^R compliance (fExecutable flag). */
! #if RTLNX_VER_RANGE(3,2,0, 5,10,0) || defined(DOXYGEN_RUNNING)
  # define IPRT_USE_ALLOC_VM_AREA_FOR_EXEC
  #endif
+ #if RTLNX_VER_MIN(5,10,0) || defined(DOXYGEN_RUNNING)
+ # define IPRT_USE_APPLY_TO_PAGE_RANGE_FOR_EXEC
+ #endif
  
  /*
   * 2.6.29+ kernels don't work with remap_pfn_range() anymore because
***************
*** 502,507 ****
--- 505,546 ----
  }
  
  
+ #ifdef IPRT_USE_APPLY_TO_PAGE_RANGE_FOR_EXEC
+ /**
+  * User data passed to the apply_to_page_range() callback.
+  */
+ typedef struct LNXAPPLYPGRANGE
+ {
+     /** Pointer to the memory object. */
+     PRTR0MEMOBJLNX pMemLnx;
+     /** The page protection flags to apply. */
+     pgprot_t       fPg;
+ } LNXAPPLYPGRANGE;
+ /** Pointer to the user data. */
+ typedef LNXAPPLYPGRANGE *PLNXAPPLYPGRANGE;
+ /** Pointer to the const user data. */
+ typedef const LNXAPPLYPGRANGE *PCLNXAPPLYPGRANGE;
+ 
+ /**
+  * Callback called in apply_to_page_range().
+  *
+  * @returns Linux status code.
+  * @param   pPte                Pointer to the page table entry for the given address.
+  * @param   uAddr               The address to apply the new protection to.
+  * @param   pvUser              The opaque user data.
+  */
+ static DECLCALLBACK(int) rtR0MemObjLinuxApplyPageRange(pte_t *pPte, unsigned long uAddr, void *pvUser)
+ {
+     PCLNXAPPLYPGRANGE pArgs = (PCLNXAPPLYPGRANGE)pvUser;
+     PRTR0MEMOBJLNX pMemLnx = pArgs->pMemLnx;
+     uint32_t idxPg = (uAddr - (unsigned long)pMemLnx->Core.pv) >> PAGE_SHIFT;
+ 
+     set_pte(pPte, mk_pte(pMemLnx->apPages[idxPg], pArgs->fPg));
+     return 0;
+ }
+ #endif
+ 
+ 
  /**
   * Maps the allocation into ring-0.
   *
***************
*** 584,589 ****
--- 623,633 ----
          else
  # endif
          {
+ #  if defined(IPRT_USE_APPLY_TO_PAGE_RANGE_FOR_EXEC)
+             if (fExecutable)
+                 pgprot_val(fPg) |= _PAGE_NX; /* Uses RTR0MemObjProtect to clear NX when memory ready, W^X fashion. */
+ #  endif
+ 
  # ifdef VM_MAP
              pMemLnx->Core.pv = vmap(&pMemLnx->apPages[0], pMemLnx->cPages, VM_MAP, fPg);
  # else
***************
*** 1851,1856 ****
--- 1895,1915 ----
          preempt_enable();
          return VINF_SUCCESS;
      }
+ # elif defined(IPRT_USE_APPLY_TO_PAGE_RANGE_FOR_EXEC)
+     PRTR0MEMOBJLNX pMemLnx = (PRTR0MEMOBJLNX)pMem;
+     if (   pMemLnx->fExecutable
+         && pMemLnx->fMappedToRing0)
+     {
+         LNXAPPLYPGRANGE Args;
+         Args.pMemLnx = pMemLnx;
+         Args.fPg = rtR0MemObjLinuxConvertProt(fProt, true /*fKernel*/);
+         int rcLnx = apply_to_page_range(current->active_mm, (unsigned long)pMemLnx->Core.pv + offSub, cbSub,
+                                         rtR0MemObjLinuxApplyPageRange, (void *)&Args);
+         if (rcLnx)
+             return VERR_NOT_SUPPORTED;
+ 
+         return VINF_SUCCESS;
+     }
  # endif
  
      NOREF(pMem);
